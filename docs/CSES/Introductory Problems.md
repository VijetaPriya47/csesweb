
---
sidebar_position: 2
---

# Weird Algorithm
## Problem Link  
[CSES Problem 1068](https://cses.fi/problemset/task/1068/)

## Problem Statement  
Consider an algorithm that takes a **positive integer n**.  
• If n is even, divide it by two.  
• If n is odd, multiply it by three and add one.  
Repeat the process until n becomes one, and print every value in the sequence, including the initial n and the final 1.

*Input*  
The only line contains an integer n (1 ≤ n ≤ 1018).

*Output*  
Print the entire sequence produced by the algorithm, separated by spaces.

Example  

```
Input
3

Output
3 10 5 16 8 4 2 1
```

## Solution  

### Approach  
This is a direct simulation of the described procedure, commonly known as the **Collatz sequence**.  
1. Read n.  
2. Print n (without a trailing space issue—handle the final newline separately).  
3. While n ≠ 1  
   • If n is even → n = n / 2  
   • Else         → n = 3 × n + 1  
   • Print the updated n.  

Because the sequence length is unbounded in theory but limited by 64-bit arithmetic in practice (n ≤ 1018), 64-bit signed integers (`long long`/`unsigned long long`) are sufficient.

### Time Complexity  
O(k) where k is the number of terms in the sequence for the given starting n. Each iteration performs O(1) work.

### Space Complexity  
O(1) — we store only the current value n and constant auxiliary variables.

### Code  

#### C++  

```
#include 
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    unsigned long long n;
    if (!(cin >> n)) return 0;

    cout << n;
    while (n != 1) {
        if (n % 2 == 0) n /= 2;
        else            n = 3 * n + 1;
        cout << ' ' << n;
    }
    cout << '\n';
    return 0;
}
```

#### Python  

```
def main():
    n = int(input().strip())
    seq = [n]
    while n != 1:
        n = n // 2 if n % 2 == 0 else 3 * n + 1
        seq.append(n)
    print(*seq)

if __name__ == "__main__":
    main()
```

#### Java  

```
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringJoiner;

public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        long n = Long.parseLong(br.readLine().trim());
        StringJoiner out = new StringJoiner(" ");
        out.add(Long.toString(n));
        while (n != 1) {
            n = (n % 2 == 0) ? n / 2 : 3 * n + 1;
            out.add(Long.toString(n));
        }
        System.out.println(out.toString());
    }
}
```

## Explanation  
The algorithm prints every intermediate value generated by repeatedly applying the Collatz rules. Because each step depends solely on the current n, constant memory suffices. I/O is optimized by buffering (C++ fast-IO flags, Java `StringJoiner`, Python splat print).

## Alternative Approaches  
Since the task only asks for the full sequence, there is no meaningful optimization beyond plain simulation.  
Possible variations:  
- Output numbers on separate lines instead of one line (not per spec).  
- Pre-computing small cycles with memoization, but memory use grows and gains are negligible for a single n.  
